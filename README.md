# Ordenacao02
Segundo projeto de Análise e Projeto de Algoritmos - UFPB

Neste exercício puramente experimental, vocês verão os efeitos das complexidades na prática.

São fornecidos três subconjuntos de entradas, diferindo quanto ao grau de ordenação das mesmas:

Subconjunto 1: vetores 10% ordenados (90% de entropia).
Subconjunto 2: vetores 50% ordenados (50% de entropia).
Subconjunto 3: vetores 90% ordenados (10% de entropia).

Cada subconjunto apresenta vetores de diferentes tamanhos gerados aleatoriamente utilizando diferentes sementes. Assim, será possível analisar os efeitos do tamanho e do tipo do subconjunto, tendo em mãos uma amostragem de tamanho razoável para propósitos estatísticos.

Dadas as implementações do exercício anterior e os conjuntos de entradas fornecidos para este exercício:

Selecione um colega que tenha implementado os algoritmos de ordenação usando uma linguagem de programação diferente da sua.
Para cada subconjunto de entrada, execute todos os algoritmos e calcule o tempo médio que cada algoritmo gasta para cada tamanho presente no subconjunto.
A pontuação deste trabalho será dividida da seguinte forma:

Análise do tempo de execução de cada algoritmo (1,0 ponto para cada aluno).
Análise comparativa entre os dois conjuntos de implementações e uma implementação padrão de ordenação fornecida nas linguagens escolhidas (1,0 ponto para a dupla).
A análise deverá ser fornecida em formato a ser escolhido pela dupla (relatório, prezi ou slides em vídeo). Torne o “produto” conciso, porém interessante. Os seguintes tipos de análise são sugeridos:

Para cada subconjunto de entradas, faça um gráfico demonstrando o crescimento do tempo de execução médio ao longo do aumento dos tamanhos dos vetores.
Para um determinado tamanho de entrada, faça um gráfico demonstrando a variação (potencialmente o crescimento) do tempo de execução médio ao longo do aumento do grau de entropia dos vetores (diferentes subconjuntos).
Ao comparar com o método padrão fornecido pela linguagem escolhida, explique o funcionamento deste método e porque ele é (in)eficiente.

As linguagens de programação utilizadas foram C++ e Java.
	Diego Filipe Souza de Lima - C++
	Matheus Lima Moura de Araújo - JAVA

O documento com toda a análise dos algoritmos esta na pasta "doc" desse mesmo repositório. 
